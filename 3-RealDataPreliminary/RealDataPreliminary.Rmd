---
title: "LRMoE RealData Preliminary"
author: "Spark Tseung"
date: "March 3, 2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(LRMoE)
library(reshape2)
library(matrixStats)
library(EnvStats)
library(CASdatasets)
```

## Introduction

This document is Part I of a demo series of the `LRMoE` (Logit-weighted Reduced Moxture-of-Experts) package on a real dataset. By analysing a French motor third-party liability insurance dataset in [`CASdatasets`](http://dutangc.free.fr/pub/RRepos/web/CASdatasets-index.html), we will demonstrate the fitting procedure, diagnostics, visualization and predictive functions of the `LRMoE` package. In this document, we focus on data preprocessing, exploratory analysis and parameter initialization.


## Data Preprocessing

In this section, we first perform some exploratory analysis on the dataset. Description of variables are given in the `CASdatasets` user manual, and will not be repeated here. `freMTPLfreq` contains records of policy ID, policyholder information and number of claims, while `freMTPLsev` contains only policy ID and claim amounts for those who have claims. The `PolicyID` variable serves as a unique identifier that links these two datasets. We note that some policyholders have multiple claims, hence `freMTPLsev$PolicyID` contains duplicated records. We aggregate claim amounts by policy and merge these two datasets.

```{r}
# Load data
data(freMTPLfreq, freMTPLsev)

# Aggregate claim amounts
sev.aggre = aggregate(freMTPLsev$ClaimAmount, 
                      by = list(PolicyID = freMTPLsev$PolicyID), FUN = "sum")
colnames(sev.aggre)[2] = "ClaimAmount"

# Match two datasets by PolicyID. NA values correspond to no claims.
df.all = merge(freMTPLfreq, sev.aggre, by = "PolicyID", all = TRUE)
df.all$ClaimAmount[is.na(df.all$ClaimAmount)] = 0
df.all.pos = df.all[which(df.all$ClaimAmount>0),]

df.temp = data.matrix(df.all)

```

The response variables are `ClaimNb` and `ClaimAmount`. For simplicity, we exclude `Exposure` and `Density` from the covariates.
```{r}
# Drop covariates: Exposure and Density
df.all = df.all[,-which(names(df.all) %in% c("Exposure", "Density"))]
df.all.pos = df.all.pos[,-which(names(df.all.pos) %in% c("Exposure", "Density"))]
```

\pagebreak

## Exploratory Analysis

We first calculate some summary statistics of `ClaimNb` and `ClaimAmount`. Less than 4% of policyholders have at least one claim, and the claim amount is right-skewed with a heavy tail.
```{r}
sample.size = nrow(df.all)

# Proportion of zero claim
sum(df.all$ClaimNb==0)/sample.size
sum(df.all$ClaimAmount==0)/sample.size

# Other statistics
summary(df.all$ClaimAmount)
sd(df.all$ClaimNb[which(df.all$ClaimNb>0)])

sd(df.all$ClaimAmount[which(df.all$ClaimAmount>0)])
kurtosis(df.all$ClaimAmount[which(df.all$ClaimAmount>0)])
```

\pagebreak

```{r, fig.align="center", fig.width = 6, fig.asp = 1}
# QQ Plot
qqnorm(df.all$ClaimAmount[which(df.all$ClaimAmount>0 )])
```

\pagebreak

```{r, fig.align="center", fig.width = 6, fig.asp = 1}
# Histogram
hist(log(df.all$ClaimAmount[which(df.all$ClaimAmount>0 & df.all$ClaimAmount<500000)]),
     breaks = 200, probability = FALSE,
     xlim = c(2, 12),
     main = "Histogram of log(ClaimAmount)", xlab = "log(ClaimAmount)")
```

\pagebreak

We can also plot the response variable against each of the covariates. For better presentation, only positive claim amounts less than 20,000 (or 5,000) are plotted.

* **Car's Age**:

```{r, eval=TRUE, echo=FALSE, fig.align='center', fig.width = 6, fig.asp = 1}
pos.idx = (df.all$ClaimAmount>0)
med.idx = (df.all$ClaimAmount<=20000)
plt.idx =  as.logical(pos.idx * med.idx)

plot(x = df.all$CarAge[plt.idx], y = df.all$ClaimAmount[plt.idx],
     xlab = "Car Age", ylab = "Claim Amount", main = "Claim Amount vs Car Age")

```

\pagebreak

* **Driver's Age**:

```{r, eval=TRUE, echo=FALSE, fig.align='center', fig.width = 6, fig.asp = 1}
plot(x = df.all$DriverAge[plt.idx], y = df.all$ClaimAmount[plt.idx],
     xlab = "Driver's Age", ylab = "Claim Amount", main = "Claim Amount vs Driver's Age")

```

\pagebreak

* **Car Power**:

```{r, eval=TRUE, echo=FALSE, fig.align='center', fig.width = 6, fig.asp = 1}
pos.idx = (df.all$ClaimAmount>0)
med.idx = (df.all$ClaimAmount<=5000)
plt.idx =  as.logical(pos.idx * med.idx)

plot(x = df.all$Power[plt.idx], y = df.all$ClaimAmount[plt.idx],
     xlab = "Type of Car Power", ylab = "Claim Amount", main = "Claim Amount vs Car Power")

```

\pagebreak

* **Brand**:

```{r, eval=TRUE, echo=FALSE, fig.align='center', fig.width = 6, fig.asp = 1}
temp.X = df.all$Brand[plt.idx]
levels(temp.X)
levels(temp.X) = c("F", "JK", "MCB", "OGF", "Other", "RNC", "VAS")

# plot(x = df.all$Brand[plt.idx], y = df.all$ClaimAmount[plt.idx],
#      xlab = "Type of Car Brand", ylab = "Claim Amount", main = "Claim Amount vs Car Brand")

plot(x = temp.X, y = df.all$ClaimAmount[plt.idx],
     xlab = "Type of Car Brand", ylab = "Claim Amount", main = "Claim Amount vs Car Brand")
```

\pagebreak

* **Gas**:

```{r, eval=TRUE, echo=FALSE, fig.align='center', fig.width = 6, fig.asp = 1}
plot(x = df.all$Gas[plt.idx], y = df.all$ClaimAmount[plt.idx],
     xlab = "Type of Car Gas", ylab = "Claim Amount", main = "Claim Amount vs Car Gas")
```

\pagebreak

* **Region**:

```{r, eval=TRUE, echo=FALSE, fig.align='center', fig.width = 6, fig.asp = 1}
temp.X = df.all$Region[plt.idx]
levels(temp.X)

levels(temp.X) = c("A", "BN", "B", "C", "HN", "IF", "L", "NPC", "PL", "PC")

# plot(x = df.all$Region[plt.idx], y = df.all$ClaimAmount[plt.idx],
#      xlab = "Region", ylab = "Claim Amount", main = "Claim Amount vs Region")

plot(x = temp.X, y = df.all$ClaimAmount[plt.idx],
     xlab = "Region", ylab = "Claim Amount", main = "Claim Amount vs Region")
```

\pagebreak

## Formatting Data

For illustration purposes, we will fit an LRMoE with one respose variable `ClaimAmount` only. The following code shows how to format input matrices `Y` and `X` required by the `LRMoE` package.

```{r}
# Make Y matrix
sample.size = nrow(df.all)
Y = matrix( c(rep(0, sample.size),    # = tl.1
              df.all$ClaimAmount,     # = yl.1
              df.all$ClaimAmount,     # = tu.1
              rep(Inf, sample.size)   # = tu.1
              ), 
           ncol = 4, byrow = FALSE)

# Make X matrix
X.continuous = cbind(df.all$CarAge, df.all$DriverAge)
X.power = model.matrix(~df.all$Power, data = df.all)     # Default Power  is 'd'
X.brand = model.matrix(~df.all$Brand, data = df.all)     # Default Brand  is 'Fiat'
X.gas = model.matrix(~df.all$Gas, data = df.all)         # Default Gas    is 'Diesel'
X.region = model.matrix(~df.all$Region, data = df.all)   # Default Region is 'Aquitaine'
X = matrix(cbind(rep(1, sample.size), # Intercept
                 X.continuous, X.power[,-1], X.brand[,-1], X.gas[,-1], X.region[,-1]),
           nrow = sample.size, byrow = FALSE)

colnames(X) = c("Intercept", "CarAge", "DriverAge",
                "Powere", "Powerf", "Powerg", "Powerh", "Poweri", "Powerj", 
                "Powerk", "Powerl", "Powerm", "Powern", "Powero",
                "BrandJK", "BrandMCB", "BrandOGF", "BrandOther", "BrandRNC", "BrandVAS",
                "GasRegular",
                "RegionBN", "RegionB", "RegionC", "RegionHN", "RegionIF", 
                "RegionL", "RegionNPC", "RegionPL", "RegionPC")

```

We will save the data for the fitting procedures later.
```{r}
save(X, file = "X.Rda")
save(Y, file = "Y.Rda")
```


## Parameter Initialization

The `LRMoE` fitting function also requires initialization of `n.comp` (number of latent components), `comp.dist` (component distributions by dimension and by component),  `zero.init` (zero inflation) and `params.init` (initialization of component distribution parameters). 

Since component distributions included in `LRMoE` are all uni-modal, a good starting point is to observe the numbers of components is to count the number of peaks in the previous histogram of data. We will consider 3~6 latent components, each with 5 combinations of component distributions. For each case, we use k-means clustering and matching of moments to roughly choose initial parameters.

```{r}
# Drop response: ClaimNb
df.all = df.all[,-which(names(df.all) %in% c("ClaimNb"))]
df.all.pos = df.all.pos[,-which(names(df.all.pos) %in% c("ClaimNb"))]
```


```{r}
# Normalize data
df.all.norm = df.all
df.all.norm= df.all.norm[,-which(names(df.all.norm) %in% c("PolicyID", "ClaimNb"))]

df.all.norm$CarAge = 
  (df.all.norm$CarAge - mean(df.all.norm$CarAge))/sd(df.all.norm$CarAge)
df.all.norm$DriverAge = 
  (df.all.norm$DriverAge - mean(df.all.norm$DriverAge))/sd(df.all.norm$DriverAge)
df.all.norm$ClaimAmount = 
  (df.all.norm$ClaimAmount - mean(df.all.norm$ClaimAmount))/sd(df.all.norm$ClaimAmount)
```

```{r}
head(df.all.norm)

summary(df.all.norm)

```

The `LRMoE` package contains a Clustered Method of Moments initialization function which is used in conjunction of `kmeans`. We look at the 3-component case in detail and skip the rest.

### 3 Latent Components

```{r}
set.seed(7777) # For reproducible results

dim.m = 1
n.comp = 3

norm.km.cluster.3 = kmeans(data.matrix(df.all.norm), n.comp)
norm.init.analysis.3 = cluster.mm.severity(df.all$ClaimAmount, norm.km.cluster.3$cluster)

```

The returned list `norm.init.analysis.3` contains cluster proportion (of the entire population), zero inflation, summary statsitics and parameter initializations for all selection of component distributions. The user can then choose which distributions to use. As a general rule of thumb, initialization with very extreme parameter values should be avoided.

For example, the initialization of the first component is as follows.

```{r}
norm.init.analysis.3[[1]]
```



### 4~6 Latent Components

```{r}
set.seed(7777) # For reproducible results

dim.m = 1
n.comp = 4

norm.km.cluster.4 = kmeans(data.matrix(df.all.norm), n.comp)
norm.init.analysis.4 = cluster.mm.severity(df.all$ClaimAmount, norm.km.cluster.4$cluster)

```


```{r}
set.seed(7777) # For reproducible results

dim.m = 1
n.comp = 5

norm.km.cluster.5 = kmeans(data.matrix(df.all.norm), n.comp)
norm.init.analysis.5 = cluster.mm.severity(df.all$ClaimAmount, norm.km.cluster.5$cluster)

```


```{r}
set.seed(7777) # For reproducible results

dim.m = 1
n.comp = 6

norm.km.cluster.6 = kmeans(data.matrix(df.all.norm), n.comp)
norm.init.analysis.6 = cluster.mm.severity(df.all$ClaimAmount, norm.km.cluster.6$cluster)

```

We will save all initilizations for use in the next step.
```{r}
save(norm.init.analysis.3, file = "RealDataInit3.Rda")
save(norm.init.analysis.4, file = "RealDataInit4.Rda")
save(norm.init.analysis.5, file = "RealDataInit5.Rda")
save(norm.init.analysis.6, file = "RealDataInit6.Rda")
```







